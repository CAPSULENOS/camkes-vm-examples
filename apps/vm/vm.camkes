/*
 * Copyright 2014, NICTA
 *
 * This software may be distributed and modified according to the terms of
 * the BSD 2-Clause license. Note that NO WARRANTY is provided.
 * See "LICENSE_BSD2.txt" for details.
 *
 * @TAG(NICTA_BSD)
 */

#include <autoconf.h>
import <std_connector.camkes>;

import "components/uart/uart.camkes";
import "components/gpio/gpio.camkes";
import "components/pilot/pilot.camkes";
import "components/VM/VM.camkes";
import "components/pwm/pwm.camkes";
import "components/spi/spi.camkes";
import "components/can/can.camkes";
import "components/clk/clk.camkes";
import "components/timer/timer.camkes";

#ifdef CONFIG_VM_VCHAN
import <Vchan/Vchan.camkes>;
import "components/helloworld/helloworld.camkes";
#endif //CONFIG_VM_VCHAN

component uartbase {
    hardware;
    dataport Buf mem;
    emits DataAvailable	irq;
}

component gpiobase {
    hardware;
    dataport Buf gpio1base;
    dataport Buf gpio2base;
    dataport Buf irqcbase;
    dataport Buf clk_tree;
    emits IRQGroup26 irq_grp26_int;
    emits IRQGroup28 irq_grp28_int;
    emits IRQGroup31 irq_grp31_int;
    emits EXINT16_31 xint16_31_int;
}

component i2c0 {
    hardware;
    dataport Buf i2c0_reg;
    emits DataAvailable i2c0_int;
}

component clkbase {
    hardware;
    dataport Buf cmu_cpu_clk;
    dataport Buf	   cmu_core_clk;
    dataport Buf cmu_top_clk;
}

component spibase {
	hardware;
	dataport Buf spi1_reg;
	emits DataAvailable spi1_int;
}

assembly {
    composition {
        component VM vm;
#ifdef CONFIG_PLAT_EXYNOS5410
        component uartbase uartbase_gcs;
        component uartbase uartbase_px4;
        component gpiobase gpiobase_obj;
        component i2c0     i2c0_obj;
        component spibase  spibase_obj;
        component clkbase   clkbase_obj;
        component timerbase timerbase_obj;

        component gpio     gpio_obj;
        component uart     uart_gcs;
        component uart     uart_px4;
        component pilot    pilot_obj;
        component pwm      pwm_obj;
        component spi      spi_obj;
        component can      can_obj;
        component clk      clk_obj;
        component timer	   timer_obj;
#endif

#ifdef CONFIG_VM_VCHAN
        component Vchan vchan_0;
        component helloworld hello;

        connection seL4RPCCall vchan(from vm.vchan_con, to vchan_0.vchan_com);
        connection seL4Notification vchan_event_init(from vchan_0.vevent_cl, to vm.vevent);
        connection seL4SharedData vchan_sharemem_0(from vm.share_mem, to vchan_0.share_mem);

        connection seL4Notification vchan_event(from vchan_0.vevent_sv, to hello.vevent);
        connection seL4SharedData hvchan_sharemem_0(from hello.share_mem, to vchan_0.share_mem);
        connection seL4RPCCall hvchan(from hello.vchan_con, to vchan_0.vchan_com);
#endif //CONFIG_VM_VCHAN

#ifdef CONFIG_PLAT_EXYNOS5410
        connection seL4HardwareMMIO gpio_mem1(from gpio_obj.gpio1base, to gpiobase_obj.gpio1base);
        connection seL4HardwareMMIO gpio_mem2(from gpio_obj.gpio2base, to gpiobase_obj.gpio2base);
        connection seL4HardwareMMIO gpio_mem3(from gpio_obj.irqcbase, to gpiobase_obj.irqcbase);
        connection seL4HardwareMMIO gpio_clk(from gpio_obj.clk_tree, to gpiobase_obj.clk_tree);

        connection seL4HardwareMMIO clk_cmu_cpu_mem(from clk_obj.cmu_cpu_clk, to clkbase_obj.cmu_cpu_clk);
        connection seL4HardwareMMIO clk_cmu_top_mem(from clk_obj.cmu_top_clk, to clkbase_obj.cmu_top_clk);
        connection seL4HardwareMMIO clk_cmu_core_mem(from clk_obj.cmu_core_clk, to clkbase_obj.cmu_core_clk);

        /* Interrupts */
        connection seL4HardwareInterrupt spi1_irq(from spibase_obj.spi1_int, to spi_obj.spi1_int);
        connection seL4HardwareInterrupt gpio_grp28_irq(from gpiobase_obj.irq_grp28_int, to gpio_obj.irq_grp28_int);
        connection seL4HardwareInterrupt gpio_grp26_irq(from gpiobase_obj.irq_grp26_int, to gpio_obj.irq_grp26_int);
        connection seL4HardwareInterrupt gpio_grp31_irq(from gpiobase_obj.irq_grp31_int, to gpio_obj.irq_grp31_int);
        connection seL4HardwareInterrupt gpio_xint16_31_irq(from gpiobase_obj.xint16_31_int, to gpio_obj.xint16_31_int);

	/* SPI connections */
        connection seL4RPCCall spi_gpio(from spi_obj.gpio, to gpio_obj.gpio);
        connection seL4RPCCall spi_clk(from spi_obj.clktree, to clk_obj.clktree);
        connection seL4HardwareMMIO spi1_mem(from spi_obj.spi1_reg, to spibase_obj.spi1_reg);

        /* Can driver */
        connection seL4RPCCall 	  can_spi(from can_obj.spi, to spi_obj.spi);
        connection seL4SharedData can_spi_channel	(from can_obj.spi_can,	to spi_obj.spi1_can);
        connection seL4Notification 	  gpio_can_int(from gpio_obj.CANInt, to can_obj.Int);
        connection seL4Notification 	  gpio_can_intAck(from can_obj.IntAck, to gpio_obj.CANIntAck);

	/* GCS hardware connection */
        connection seL4HardwareMMIO uartbase_mem(from uart_gcs.uart0base, to uartbase_gcs.mem);
        connection seL4HardwareInterrupt uartbase_irq(from uartbase_gcs.irq, to uart_gcs.interrupt);

	/* PX4 hardware connection */
        connection seL4HardwareMMIO uartpx4_mem(from uart_px4.uart0base, to uartbase_px4.mem);
        connection seL4HardwareInterrupt uartpx4_irq(from uartbase_px4.irq, to uart_px4.interrupt);

	/* Pilot connection */
        connection seL4RPCCall uart_inf(from pilot_obj.uart_gcs, to uart_gcs.uart);
        connection seL4SharedData uart_data(from pilot_obj.gcs_buf, to uart_gcs.client_buf);

        connection seL4RPCCall uartpx4_inf(from pilot_obj.uart_px4, to uart_px4.uart);
        connection seL4SharedData uartpx4_data(from pilot_obj.px4_buf, to uart_px4.client_buf);

	/* Recv connection */
        connection seL4RPCCall gcs_recv_inf(from uart_gcs.pilot, to pilot_obj.mavlink);
        connection seL4RPCCall px4_recv_inf(from uart_px4.pilot, to pilot_obj.mavlink);

        /* PWM connection */
        connection seL4HardwareMMIO      i2c0_mem(from pwm_obj.i2c0, to i2c0_obj.i2c0_reg);
        connection seL4HardwareInterrupt i2c0_irq(from i2c0_obj.i2c0_int, to pwm_obj.i2c0_int);
        connection seL4RPCCall           fd_pwm(from pilot_obj.pwm, to pwm_obj.pwm);
        connection seL4Notification pwm_sig(from pilot_obj.signal, to pwm_obj.signal);
        connection seL4Notification pwm_timer(from timer_obj.timer_update, to pwm_obj.timer_update);

	/* PWM timer connections */
        connection seL4HardwareMMIO timer_mem(from timer_obj.timerbase, to timerbase_obj.timer_reg);
        connection seL4HardwareInterrupt timer_irq(from timerbase_obj.irq, to timer_obj.irq);

	/* VM to PWM */
        connection seL4RPCCall           vm_pwm(from vm.pwm, to pwm_obj.pwm);

	/* Restart VM */
	connection seL4Notification restart_vm(from pilot_obj.restart_vm, to vm.restart_event);
#endif
    }

    configuration {
#ifdef CONFIG_PLAT_EXYNOS5410
        uartbase_gcs.mem_paddr = 0x12C30000;
        uartbase_gcs.mem_size = 0x1000;
        uartbase_gcs.irq_irq_number = 86;                        //UART1 interrupt

        uartbase_px4.mem_paddr = 0x12C10000;
        uartbase_px4.mem_size = 0x1000;
        uartbase_px4.irq_irq_number = 84;                        //UART1 interrupt

        gpiobase_obj.gpio2base_paddr = 0x14000000;
        gpiobase_obj.gpio2base_size = 0x1000;

        gpiobase_obj.gpio1base_paddr = 0x13400000;
        gpiobase_obj.gpio1base_size = 0x1000;

        gpiobase_obj.clk_tree_paddr = 0x10020000;
        gpiobase_obj.clk_tree_size = 0x1000;

        gpiobase_obj.irqcbase_paddr = 0x10440000;
        gpiobase_obj.irqcbase_size = 0x1000;

        gpiobase_obj.irq_grp26_int_irq_number = 58; //Combined IRQ group 26
        gpiobase_obj.irq_grp28_int_irq_number = 60; //Combined IRQ group 28
        gpiobase_obj.irq_grp31_int_irq_number = 63; //Combined IRQ group 31
        gpiobase_obj.xint16_31_int_irq_number = 64; //Extern Interrupt EINT16-EINT31

        spibase_obj.spi1_reg_paddr = 0x12D30000;
        spibase_obj.spi1_reg_size = 0x1000;
        spibase_obj.spi1_int_irq_number = 101;                    //SPI1  interrupt

        clkbase_obj.cmu_cpu_clk_paddr = 0x10010000;
        clkbase_obj.cmu_cpu_clk_size = 0x1000;

        clkbase_obj.cmu_core_clk_paddr = 0x10014000;
        clkbase_obj.cmu_core_clk_size = 0x1000;

        clkbase_obj.cmu_top_clk_paddr = 0x10020000;
        clkbase_obj.cmu_top_clk_size = 0x1000;

        i2c0_obj.i2c0_reg_paddr = 0x12C60000;
        i2c0_obj.i2c0_reg_size = 0x1000;
        i2c0_obj.i2c0_int_irq_number = 88;

        timerbase_obj.timer_reg_paddr = 0x12DD0000;
        timerbase_obj.timer_reg_size = 0x1000;
        timerbase_obj.irq_irq_number	       = 72;			//Timer interrupt

	uart_gcs.ID = 1;
	uart_px4.ID = 3;
        /* MMIO regions are
            0x10000000 CHIP_ID
            0x10486000 VCPU
            0x12c20000 UART2
            0x13400000 GPIO_RIGHT
            0x10040000 POWER0
            0x10041000 POWER1
            0x10042000 POWER2
            0x10043000 POWER3
            0x10044000 POWER4
            0x10050000 SYSREG
            0x10020000 CMU_TOP
            0x10014000 CMU_CORE
            0x10010000 CMU_CPU
            0x10030000 CMU_COREX
            0x10038000 CMU_MEM
            0x1001c000 CMU_ISP
            0x10018000 CMU_ACP
            0x12110000 USB EHCI
            0x12130000 USB CTRL
            0x12200000 MSH0
            0x12220000 MSH2
            0x40000000 RAM
        */
        vm.untyped_mmios = "0x10000000:12,
                    0x10486000:12,
                    0x12c20000:12,
                    0x10040000:12,
                    0x10041000:12,
                    0x10042000:12,
                    0x10043000:12,
                    0x10044000:12,
                    0x10050000:12,
                    0x10030000:12,
                    0x10038000:12,
                    0x1001c000:12,
                    0x10018000:12,
                    0x12110000:12,
                    0x12130000:12,
                    0x12200000:12,
                    0x12220000:12,
                    0x40000000:29";
        vm.mmios = "0x10010000:0x1000:12,
                    0x10020000:0x1000:12,
                    0x13400000:0x1000:12,
                    0x10014000:0x1000:12";

        /* IRQs are
            27  VTCNT (arch timer)
            85  UART2
            107 SDMMC0
            109 SDMMC2
            103 USB
        */
        vm.irqs =  "27,
                    85,
                    107,
                    109,
                    103";

#endif

#ifdef CONFIG_PLAT_TK1
        vm.untyped_mmios = [
           //         "0x01000000:12", // PCIe Controller 0 config registers
           //         "0x01001000:12", // PCIe Controller 1 config registers
           //         "0x01003000:12", // PCIe Pads & AFI
           //         "0x02000000:20", // Start of PCIE_A2 region
           //         "0x13000000:20", // In PCIE_A3 region 
                    "0x50046000:12", // Interrupt Controller Virtual CPU interface (Virtual Machine view)
                                   //  Note: In the address map this region is 8KB, but we only pass through 4KB
                    "0x60004000:12", // Interrupt controller registers (ICTLR)
           //         "0x60005000:12", // Timers (TMR)
                    "0x60006000:12", // Clock and Reset (CAR)
           //         "0x6000c000:12", // System Registers, AHB Arbitration + Gizmo Controller, AHB/APB Debug Bus, Secure Boot, STAT-MON, Activity Monitor 
                    "0x6000d000:12", // GPIOS 1-8
              //      "0x60020000:12", // APB-DMA 
                    "0x70000000:12", // APB-MISC: pinmux@0x70000868
                    "0x70006000:12", // UARTA, UARTB, VFIR, UARTC, UARTD, HDMI_IOBIST, MIPI_IOBIST, LPDDR2_IOBIST, PCIE_X2_0_IOBIST, PCIE_X2_1_IOBIST, PCIE_X4_IOBIST, SATA_IOBIST
              //      "0x7000c000:12", // I2C, TWC, DTV, I2C2, I2C3, OWR, I2C4
              //      "0x7000d000:12", // I2C5, I2C6, SPI 2B-(1..6)
              //      "0x7000e000:12", // RTC, KBC, PMC
              //      "0x7001b000:12", // EMC
              //      "0x70020000:12", // SATA
              //      "0x70021000:12", // SATA
              //      "0x70027000:12", // SATA
              //      "0x70030000:12", // HDA
              //      "0x70031000:12", // HDA
              //      "0x70038000:12", // HDA
              //      "0x7009f000:12", // XUSB_PADCTL TODO: Look into pads
                    "0x700b0000:12", // SDMMC-1
              //      "0x70300000:12", // Audio Cluster
              //      "0x70301000:12", // Audio Cluster
                    "0x7d000000:12", // USB
                    "0x7d004000:12", // USB2
              //      "0x7d008000:12", // USB3
                    "0xb0000000:28", // Linux kernel memory regions
                    "0xc0000000:29", // Linux kernel memory regions
                    "0xe0000000:28"];// Linux kernel memory regions
        vm.irqs =  [27, // INTERRUPT_VGPT (INTERRUPT_PPI_11)
               //     32, // INTERRUPT_TMR1
               //     33, // INTERRUPT_TMR2
               //     34, // INTERRUPT_RTC
                    35, // INTERRUPT_CEC
                    36, // INTERRUPT_SHR_SEM_INBOX_FULL
                    37, // INTERRUPT_SHR_SEM_INBOX_EMPTY
                    38, // INTERRUPT_SHR_SEM_OUTBOX_FULL
                    39, // INTERRUPT_SHR_SEM_OUTBOX_EMPTY
                    40, // INTERRUPT_VDE_UCQ
                    41, // INTERRUPT_VDE_SYNC_TOKEN
                    42, // INTERRUPT_VDE_BSEV
                    43, // INTERRUPT_VDE_BSEA
                    44, // INTERRUPT_VDE_SXE
                    45, // INTERRUPT_SATA_RX_STAT
             //       46, // INTERRUPT_SDMMC1
             //       47, // INTERRUPT_SDMMC2
                    49, // INTERRUPT_VDE
                    50, // INTERRUPT_AVP_UCQ
             //       51, // INTERRUPT_SDMMC3
             //       52, // INTERRUPT_USB
                    53, // INTERRUPT_KEYPAD
             //       54, // INTERRUPT_USB2
                    56, // INTERRUPT_SATA_CTL
                    58, // INTERRUPT_VCP
                    59, // INTERRUPT_APB_DMA_CPU
                    60, // INTERRUPT_AHB_DMA_CPU
                    61, // INTERRUPT_ARB_SEM_GNT_CPU
                    62, // INTERRUPT_OWR
                    63, // INTERRUPT_SDMMC4
                    64, // INTERRUPT_GPIO1
                    65, // INTERRUPT_GPIO2
                    66, // INTERRUPT_GPIO3
                    67, // INTERRUPT_GPIO4
             //       68, // INTERRUPT_UARTA
             //       69, // INTERRUPT_UARTB
             //       70, // INTERRUPT_I2C
             //       71, // INTERRUPT_USB3_HOST
             //       72, // INTERRUPT_USB3_HOST_SMI
             //       73, // INTERRUPT_TMR3
             //       74, // INTERRUPT_TMR4
             //       75, // INTERRUPT_USB3_HOST_PME
             //       76, // INTERRUPT_USB3_DEV_HOST
             //       77, // INTERRUPT_ACTMON
             //       78, // INTERRUPT_UARTC
                    79, // INTERRUPT_HSI
             //       80, // INTERRUPT_THERMAL
             //       81, // INTERRUPT_XUSB_PADCTL
                    82, // INTERRUPT_TSEC
                    83, // INTERRUPT_EDP
                    84, // INTERRUPT_VFIR
             //       85, // INTERRUPT_I2C5
                    86, // INTERRUPT_STAT_MON
                    87, // INTERRUPT_GPIO5
             //       88, // INTERRUPT_USB3_DEV_SMI
             //       89, // INTERRUPT_USB3_DEV_PME
                    90, // INTERRUPT_SE
             //       91, // INTERRUPT_SPI1
                    92, // INTERRUPT_APB_DMA_COP
                    93, // INTERRUPT_AHB_DMA_COP
             //       94, // INTERRUPT_CLDVFS
             //       95, // INTERRUPT_I2C6
                    96, // INTERRUPT_HOST1X_SYNCPT_COP
                //    97, // INTERRUPT_HOST1X_SYNCPT_CPU
                    98, // INTERRUPT_HOST1X_GEN_COP
                //    99, // INTERRUPT_HOST1X_GEN_CPU
                    100, // INTERRUPT_MSENC
                    101, // INTERRUPT_VI
                    102, // INTERRUPT_ISPB
                    103, // INTERRUPT_ISP
                    104, // INTERRUPT_VIC
                //    105, // INTERRUPT_DISPLAY
                //    106, // INTERRUPT_DISPLAYB
                //    107, // INTERRUPT_HDMI
                //    108, // INTERRUPT_SOR
                //    110, // INTERRUPT_EMC
                //    111, // INTERRUPT_SPI6
                //    113, // INTERRUPT_HDA
                //    114, // INTERRUPT_SPI2
                //    115, // INTERRUPT_SPI3
                //    116, // INTERRUPT_I2C2
                //    118, // INTERRUPT_PMU_EXT
                    119, // INTERRUPT_GPIO6
                    121, // INTERRUPT_GPIO7
                    122, // INTERRUPT_UARTD
                //    124, // INTERRUPT_I2C3
                    127, // INTERRUPT_SW
                    128, // INTERRUPT_SNOR
                //    129, // INTERRUPT_USB3
                //    130, // INTERRUPT_PCIE_INT
                //    131, // INTERRUPT_PCIE_MSI
                //    132, // INTERRUPT_PCIE_WAKE
                    133, // INTERRUPT_AVP_CACHE
                //    135, // INTERRUPT_AUDIO_CLUSTER
                //    136, // INTERRUPT_APB_DMA_CH0
                //    137, // INTERRUPT_APB_DMA_CH1
                //    138, // INTERRUPT_APB_DMA_CH2
                //    139, // INTERRUPT_APB_DMA_CH3
                //    140, // INTERRUPT_APB_DMA_CH4
                //    141, // INTERRUPT_APB_DMA_CH5
                //    142, // INTERRUPT_APB_DMA_CH6
                //    143, // INTERRUPT_APB_DMA_CH7
                //    144, // INTERRUPT_APB_DMA_CH8
                //    145, // INTERRUPT_APB_DMA_CH9
                //    146, // INTERRUPT_APB_DMA_CH10
                //    147, // INTERRUPT_APB_DMA_CH11
                //    148, // INTERRUPT_APB_DMA_CH12
                //    149, // INTERRUPT_APB_DMA_CH13
                //    150, // INTERRUPT_APB_DMA_CH14
                //    151, // INTERRUPT_APB_DMA_CH15
                //    152, // INTERRUPT_I2C4
                //    153, // INTERRUPT_TMR5
                //    154, // INTERRUPT_HIER_GROUP1_COP
                    155, // INTERRUPT_WDT_CPU
                    156, // INTERRUPT_WDT_AVP
                    157, // INTERRUPT_GPIO8
                    158, // INTERRUPT_CAR
                    159, // INTERRUPT_HIER_GROUP1_CPU
                //    160, // INTERRUPT_APB_DMA_CH16
                //    161, // INTERRUPT_APB_DMA_CH17
                //    162, // INTERRUPT_APB_DMA_CH18
                //    163, // INTERRUPT_APB_DMA_CH19
                //    164, // INTERRUPT_APB_DMA_CH20
                //    165, // INTERRUPT_APB_DMA_CH21
                //    166, // INTERRUPT_APB_DMA_CH22
                //    167, // INTERRUPT_APB_DMA_CH23
                //    168, // INTERRUPT_APB_DMA_CH24
                //    169, // INTERRUPT_APB_DMA_CH25
                //    170, // INTERRUPT_APB_DMA_CH26
                //    171, // INTERRUPT_APB_DMA_CH27
                //    172, // INTERRUPT_APB_DMA_CH28
                //    173, // INTERRUPT_APB_DMA_CH29
                //    174, // INTERRUPT_APB_DMA_CH30
                //    175, // INTERRUPT_APB_DMA_CH31
                    176, // INTERRUPT_CPU0_PMU
                    177, // INTERRUPT_CPU1_PMU
                    178, // INTERRUPT_CPU2_PMU
                    179, // INTERRUPT_CPU3_PMU
                    180, // INTERRUPT_SDMMC1_SYS
                    181, // INTERRUPT_SDMMC2_SYS
                    182, // INTERRUPT_SDMMC3_SYS
                    183, // INTERRUPT_SDMMC4_SYS
                    184, // INTERRUPT_TMR6
                    185, // INTERRUPT_TMR7
                    186, // INTERRUPT_TMR8
                    187, // INTERRUPT_TMR9
                    188, // INTERRUPT_TMR0
                //    189, // INTERRUPT_GPU
                //    190, // INTERRUPT_GPU_NONSTALL
                //    191  // ARDPAUX
                    ];

        vm.smmu = [10, 24];
#endif

        vm.asid_pool = true;

        vm.simple = true;
        vm.cnode_size_bits = 23;
        vm.simple_untyped24_pool = 10;

	vm.base_prio = 100;
	vm.num_extra_frame_caps = 0;
	vm.extra_frame_map_address = 0;

	vm._priority = 101;
	vm.sem_value = 0;
    }
}
